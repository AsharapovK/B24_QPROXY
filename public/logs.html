<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Логи сервера</title>
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />
    <link
      href="https://cdn.jsdelivr.net/npm/material-components-web@14.0.0/dist/material-components-web.min.css"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="/styles.css"
    />

    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Roboto+Mono:wght@400;500&display=swap"
      rel="stylesheet"
    />
    <link
      rel="icon"
      type="image/svg+xml"
      href="/favicon.svg"
    />
  </head>

  <body>
    <div id="app">
      <nav class="nav-menu">
        <ul>
          <li>
            <a
              href="/"
              :class="{ active: currentPage === 'logs' }"
              @click.prevent="navigate('logs')"
            >
              <i class="material-icons">list_alt</i>
              Логи
            </a>
          </li>
          <li>
            <a
              href="/chart"
              :class="{ active: currentPage === 'chart' }"
              @click.prevent="navigate('chart')"
            >
              <i class="material-icons">bar_chart</i>
              Статистика
            </a>
          </li>
        </ul>
      </nav>

      <div>
        <div>
          <div class="filters">
            <button @click="refreshLogs">
              <span>Обновить</span>
            </button>
            <!-- <h4>Текущая очередь</h4> -->
            <div
              v-if="queueInfo.size === 0"
              class="text-muted"
            >
              Очередь пуста
            </div>
            <div
              v-else
              class="queue-details"
            >
              <div class="mdc-typography--body1 queue-stat">
                <span
                  class="material-icons mdc-list-item__graphic"
                  aria-hidden="true"
                  >list_alt</span
                >
                <span>Всего в очереди: <strong>{{ queueInfo.size }}</strong></span>
              </div>
              <div class="mdc-typography--body1 queue-stat">
                <span
                  class="material-icons mdc-list-item__graphic"
                  aria-hidden="true"
                  >hourglass_top</span
                >
                <span>Выполняется: <strong>{{ queueInfo.pending }}</strong></span>
              </div>
              <div
                v-if="queueInfo.queue && queueInfo.queue.length > 0"
                class="queue-items"
              >
                <h4 class="mdc-typography--subtitle1">Активные задачи:</h4>
                <ul class="mdc-list mdc-list--non-interactive">
                  <li
                    v-for="(item, index) in queueInfo.queue"
                    :key="index"
                    class="mdc-list-item queue-item"
                  >
                    <span class="mdc-list-item__text">
                      <span class="mdc-list-item__primary-text">#{{ item.id }}</span>
                      <span class="mdc-list-item__secondary-text">{{ item.status }}</span>
                    </span>
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div
        v-if="loading"
        class="text-center py-5"
      >
        <div
          class="mdc-circular-progress mdc-circular-progress--indeterminate"
          role="progressbar"
        >
          <div class="mdc-circular-progress__determinate-container">
            <svg
              class="mdc-circular-progress__determinate-circle-graphic"
              viewBox="0 0 48 48"
              xmlns="http://www.w3.org/2000/svg"
            >
              <circle
                class="mdc-circular-progress__determinate-track"
                cx="24"
                cy="24"
                r="18"
                stroke-width="4"
              />
              <circle
                class="mdc-circular-progress__determinate-circle"
                cx="24"
                cy="24"
                r="18"
                stroke-width="4"
              />
            </svg>
          </div>
          <div class="mdc-circular-progress__indeterminate-container">
            <div class="mdc-circular-progress__circle-clipper mdc-circular-progress__circle-left">
              <svg
                class="mdc-circular-progress__indeterminate-circle-graphic"
                viewBox="0 0 48 48"
                xmlns="http://www.w3.org/2000/svg"
              >
                <circle
                  cx="24"
                  cy="24"
                  r="18"
                  stroke-width="4"
                  stroke-dasharray="113.097"
                  stroke-dashoffset="56.549"
                />
              </svg>
            </div>
            <div class="mdc-circular-progress__gap-patch">
              <svg
                class="mdc-circular-progress__indeterminate-circle-graphic"
                viewBox="0 0 48 48"
                xmlns="http://www.w3.org/2000/svg"
              >
                <circle
                  cx="24"
                  cy="24"
                  r="18"
                  stroke-width="3.2"
                  stroke-dasharray="113.097"
                  stroke-dashoffset="56.549"
                />
              </svg>
            </div>
            <div class="mdc-circular-progress__circle-clipper mdc-circular-progress__circle-right">
              <svg
                class="mdc-circular-progress__indeterminate-circle-graphic"
                viewBox="0 0 48 48"
                xmlns="http://www.w3.org/2000/svg"
              >
                <circle
                  cx="24"
                  cy="24"
                  r="18"
                  stroke-width="4"
                  stroke-dasharray="113.097"
                  stroke-dashoffset="56.549"
                />
              </svg>
            </div>
          </div>
        </div>
      </div>

      <div
        v-else
        class="logs-container"
      >
        <div
          v-if="logs.length === 0"
          class="alert alert-info"
        >
          Логи отсутствуют
        </div>
        <div v-else>
          <div class="mb-3">Показано {{ logs.length }} из {{ logInfo.total }} записей</div>
          <div
            v-for="(log, index) in logs"
            :key="index"
            class="log-entry"
            :class="'log-' + (log.level || 'info') + (log.isNew ? ' new-entry' : '')"
          >
            <strong>{{ log.timestamp }}</strong> [{{ (log.level || 'info').toUpperCase() }}]: {{ log.message || log }}
            <div
              v-if="log.stack"
              class="text-danger"
            >
              {{ log.stack }}
            </div>
          </div>
        </div>
      </div>
    </div>

    <script src="https://unpkg.com/vue@3.4.0/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/material-components-web@14.0.0/dist/material-components-web.min.js"></script>
    <script>
      const { createApp, ref, onMounted } = Vue;

      const app = createApp({
        setup() {
          const logs = ref([]);
          const loading = ref(true);
          const logInfo = ref({
            total: 0,
            shown: 0,
          });
          const queueInfo = ref({
            size: 0,
            pending: 0,
            queue: [],
          });
          const startDate = ref("");
          const endDate = ref("");
          const stats = ref({
            totalRequests: 0,
            errors: 0,
            retries: 0,
          });
          const currentPage = ref("logs");

          const markExistingEntries = (entries) => {
            return entries.map((entry) => ({
              ...entry,
              isNew: false,
              id: entry.id || Date.now() + Math.random().toString(36).substr(2, 9),
            }));
          };

          const markNewEntries = (currentLogs, newLogs) => {
            const currentIds = new Set(currentLogs.map((log) => log.id));
            return newLogs.map((entry) => {
              const isNew = !currentIds.has(entry.id);
              return {
                ...entry,
                isNew,
                id: entry.id || Date.now() + Math.random().toString(36).substr(2, 9),
              };
            });
          };

          const fetchLogs = async () => {
            try {
              loading.value = true;
              const response = await axios.get("/api/logs");
              if (response.data.success) {
                const newLogs = markNewEntries(logs.value, response.data.logs);
                logs.value = markExistingEntries(newLogs);

                logInfo.value = {
                  total: response.data.total,
                  shown: response.data.shown,
                };

                // Удаляем класс new-entry после анимации
                setTimeout(() => {
                  logs.value = logs.value.map((log) => ({
                    ...log,
                    isNew: false,
                  }));
                }, 1000);
              }
            } catch (error) {
              console.error("Ошибка при загрузке логов:", error);
            } finally {
              loading.value = false;
            }
          };

          const fetchQueue = async () => {
            try {
              const response = await axios.get("/api/queue");
              if (response.data.success) {
                queueInfo.value = response.data;
              }
            } catch (error) {
              console.error("Ошибка при загрузке очереди:", error);
            }
          };

          const fetchStats = async () => {
            try {
              const response = await axios.get("/api/request-stats-detailed", {
                params: {
                  startDate: startDate.value,
                  endDate: endDate.value,
                },
              });
              if (response.data.success) {
                stats.value = response.data.stats;
              }
            } catch (error) {
              console.error("Ошибка при получении статистики:", error);
            }
          };

          const refreshAll = () => {
            fetchLogs();
            fetchQueue();
            fetchStats();
          };

          const navigate = (page) => {
            currentPage.value = page;
            if (page === "chart") {
              window.location.href = "/chart";
            }
          };

          // Подключение к WebSocket серверу
          const connectWebSocket = () => {
            const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
            const wsUrl = `${protocol}${window.location.host}`;
            
            const ws = new WebSocket(wsUrl);
            
            ws.onopen = () => {
              console.log('WebSocket соединение установлено');
            };
            
            ws.onmessage = (event) => {
              const data = JSON.parse(event.data);
              if (data.type === 'logs_updated') {
                console.log('Получено уведомление об обновлении логов');
                fetchLogs();
              }
            };
            
            ws.onclose = () => {
              console.log('WebSocket соединение закрыто, переподключение через 5 секунд...');
              setTimeout(connectWebSocket, 5000);
            };
            
            ws.onerror = (error) => {
              console.error('WebSocket ошибка:', error);
              ws.close();
            };
            
            return ws;
          };
          
          onMounted(() => {
            // Загружаем логи при загрузке страницы
            refreshAll();
            
            // Устанавливаем соединение с WebSocket сервером
            connectWebSocket();
          });

          return {
            logs,
            loading,
            logInfo,
            queueInfo,
            startDate,
            endDate,
            stats,
            fetchStats,
            refreshLogs: refreshAll,
            currentPage,
            navigate,
          };
        },
      }).mount("#app");
    </script>
  </body>
</html>
